<?php
define('ROOT_PATH', $_SERVER['DOCUMENT_ROOT']);

class Mage_Core_Helper_Custom extends Mage_Core_Helper_Data
{
	# Function to generate custom log file on root path start:
    public static function putToLog($content, $fileName = null, $inLogDir = false) {
        $logDir = ($inLogDir === true) ? self::getBaseDir('log') : MAGENTO_ROOT;

        if(is_null($fileName)) $fh = fopen($logDir."/debug.log", "a+");
        else $fh = fopen($logDir."/$fileName", "a+");

        if(is_array($content) || is_object($content)) {
            ob_start();
            echo "<pre/>";print_r($content);
            $content = ob_get_clean();
        }

        if($fh) {
            fwrite($fh, "[".date("d.m.Y h:i:s")."] ".$content."\n");
            fclose($fh);
            return true;
        }
    }
    # Function to generate custom log file on root path end....

    # Function to log class name and methods available of any object start:
    public static function logClassDetails($object) {
        self::putToLog('Class Name:', 'classDetails.log', false);
        self::putToLog(get_class($object), 'classDetails.log', false);
        self::putToLog('Class Methods:', 'classDetails.log', false);
        self::putToLog(print_r(get_class_methods($object), true), 'classDetails.log', false);
        return true;
    }
    # Function to log class name and methods available of any object end....

    # Function to log sql-query generated by any collection object start:
    public static function logCollQuery($collection) {
        #self::logClassDetails($collection);
        self::putToLog(get_class($collection), 'collClassName.log', false);
        return self::putToLog($collection->getSelect()->__toString(), 'collQuery.log', false);
    }
    # Function to log sql-query generated by any collection object end....

    ## Check if a value exists in a multi-dimensional array start:
	public static function inArrayR($needle, $haystack, $strict = false) {
		foreach ($haystack as $item) {
			if (($strict ? $item === $needle : $item == $needle) || (is_array($item) && self::inArrayR($needle, $item, $strict))) {
				return true;
			}
		}
		return false;
	}
	## Check if a value exists in a multi-dimensional array finish....

	public function inContent($needle, $haystack, $case_sensitive = true) {
		return ($case_sensitive === true) ? strpos($needle, $haystack) !== false : stripos($needle, $haystack) !== false;
	}

	public function getExecutedScript($n) {
		$stack = debug_backtrace();
		$firstFrame = $stack[count($stack) - $n];
		return $initialFile = $firstFrame['file'];
	}

	public function logAllExecutedScripts() {
		$stack = debug_backtrace();

		ob_start();
		debug_print_backtrace();
		$content = ob_get_clean();

		$file = fopen("backTrace.log", "a+");
		$pieces = str_split($content, 1024 * 4);
		foreach ($pieces as $piece) {
			fwrite($file, $piece, strlen($piece));
		}
		fclose($file);
	}

	public static function logDebugBacktrace() {
		$stack = debug_backtrace();
		
		ob_start();
		debug_print_backtrace();
		$content = ob_get_clean();

		$file = fopen("backTrace.log", "a+");
		$pieces = str_split($content, 1024 * 4);
		foreach ($pieces as $piece) {
			fwrite($file, $piece, strlen($piece));
		}
		fclose($file);
	}
}
